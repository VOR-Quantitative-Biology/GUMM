#' Identify homozygous cells
#'
#' Find homozygous cells from CRISPResso output by fitting Skewed-normal or Gaussian mixture model to dominant allele frequency distribution. Homozygous cells include unedited WT and biallelic edited cells.
#'
#' @param cleaned_crispresso_allele_df Cleaned allele dataframe generated by `clean_crispresso_output()`
#' @param output_model_fit Logical indicating if the model fit should be included in function output. Default is FALSE.
#' @param model_type String specifying whether to use a standard Gaussian mixture model ("GMM") or a skewed normal mixture model ("FMSMSN")
#' @param hard_thr If largest cluster mean is less than this percent value a warning is thrown suggesting absence of homozygous population in sample. Defaults to 75.
#' @param prob Cutoff for genotype prediction probability calculated by model fit. Defaults to 0.95.
#' @param dip_test_p_cutoff P-value cutoff for Hartigan's dip test of multimodality. If significant, a k=2 GMM model will be fit. Defaults to 0.2.
#' @param seed Seed for GMM initialization
#' @param ... Additional arguments passed to `mclust::Mclust()` or `mixsmsn::smsn.search()`
#' @returns A list with cell genotype counts, barcodes of homozygous cells, input dataframe, and optional mixture model fit object
#' @examples
#'
#' data(cocktail)
#' mydata <- clean_crispresso_output(cocktail)
#' myhoms <- find_homs(mydata)
#'
#' @importFrom mclust
find_homs <- function(cleaned_crispresso_allele_df,
                      output_model_fit = FALSE,
                      model_type = "FMSMSN",
                      hard_thr = 75,
                      prob = 0.95,
                      dip_test_p_cutoff = 0.2,
                      seed = 92365,
                      ...) {

  dom_allele_df <- cleaned_crispresso_allele_df %>%
    dplyr::group_by(sample) %>%
    dplyr::reframe(dom_allele_pct = max(percent_reads),
                   unedited = unedited[which.max(percent_reads)]) %>%
    dplyr::ungroup() %>%
    dplyr::select(sample, unedited, dom_allele_pct)

  myp <- diptest::dip.test(dom_allele_df$dom_allele_pct)$p.value
  if (myp > dip_test_p_cutoff) {
    stop("Cannot analyze monoclonal population. Either your sample is perfectly edited with a single genotype, completely unedited, or there is an issue with CRISPResso2 output.")
  }

  if (model_type == "GMM") {

    set.seed(seed)
    bic <- mclust::mclustBIC(dom_allele_df$dom_allele_pct, G = 1:2)
    model_fit <- mclust::Mclust(dom_allele_df$dom_allele_pct, x = bic, ...)

    if (max(model_fit$parameters$mean) < hard_thr) {
      warning(glue::glue("There doesn't seem to be any homozygous cells in your sample.\nThe average dominant allele frequency for the 'Hom' population ({max(model_fit$parameters$mean)}) is less than 75%"))
    }

    hom_clust_label <- names(model_fit$parameters$mean)[which.max(model_fit$parameters$mean)]
    hom_df <- tibble::tibble(dom_allele_df,
                             gmm_hom = dplyr::case_when(as.character(model_fit$classification) == hom_clust_label & !dom_allele_df$unedited ~ "homozygous_edit",
                                                        as.character(model_fit$classification) == hom_clust_label & dom_allele_df$unedited ~ "WT",
                                                        TRUE ~ "heterozygous_or_multiplet")) %>%
      dplyr::mutate(probability = apply(model_fit$z, 1, max))

  } else if (model_type == "FMSMSN") {

    set.seed(seed)
    model_fit <- mixsmsn::smsn.search(y = dom_allele_df$dom_allele_pct,
                                      nu = 1,
                                      family = "Skew.normal",
                                      g.min = 1,
                                      g.max = 2,
                                      obs.prob = TRUE,
                                      ...)

    #hom_clust_label <- which.max(model_fit$best.model$mu)

    dom_allele_df <- dom_allele_df %>%
      dplyr::mutate(cluster_label = model_fit$best.model$group)

    cluster_1_mean <- mean(dom_allele_df$dom_allele_pct[dom_allele_df$cluster_label == 1])
    cluster_2_mean <- mean(dom_allele_df$dom_allele_pct[dom_allele_df$cluster_label == 2])
    hom_clust_label <- which.max(c(cluster_1_mean, cluster_2_mean))

    hom_df <- tibble::tibble(dom_allele_df,
                             gmm_hom = dplyr::case_when(model_fit$best.model$group == hom_clust_label & !dom_allele_df$unedited ~ "homozygous_edit",
                                                        model_fit$best.model$group == hom_clust_label & dom_allele_df$unedited ~ "WT",
                                                        TRUE ~ "heterozygous_or_multiplet")) %>%
      dplyr::mutate(probability = apply(model_fit$best.model$obs.prob, 1, max)) %>%
      dplyr::select(-cluster_label)

  }

  if (!is.null(prob)) {
    hom_df <- hom_df %>%
      dplyr::mutate(gmm_hom = ifelse(gmm_hom %in% c("WT", "homozygous_edit") & probability < prob, "heterozygous_or_multiplet", gmm_hom))
  }

  output_object <- list(
    count_table = table(hom_df$gmm_hom),
    homozygous_barcodes = list(
      edited = hom_df$sample[hom_df$gmm_hom == "homozygous_edit"],
      WT = hom_df$sample[hom_df$gmm_hom == "WT"]
    ),
    data = hom_df
  )

  if (output_model_fit) {
    output_object = c(output_object, list(mix_model_fit = model_fit))
  }

  return(output_object)

}

#' Separate putative heterozygous cells from transparent multiplets
#'
#' Find putative heterozygous cells from CRISPResso output by fitting Gaussian mixture model to the log2 ratio of the 2nd and 3rd (noise) allele frequencies. Cells with no noise allele are whitelisted as true heterozygous or homozygous if they were already identified in *find_homs()*. Cells with higher log2 ratios have lower noise allele counts and are more likely to be true heterozygous cells instead of multiplets.
#'
#' @param cleaned_crispresso_allele_df Cleaned allele dataframe generated by `clean_crispresso_output()`
#' @param hom_object Optional. List object output by *find_homs()*. If no object is provided, `find_homs()` will automatically be executed.
#' @param output_hom Logical indicating if `find_homs()` model fit should be output.
#' @param output_model_fit Logical indicating if the heterozygous model fit should be included in function output. Default is FALSE.
#' @param seed Seed for GMM initialization
#' @param min_cell_number Minimum number of cells to model. If number of cells falls below this number transparent multiplet detection is skipped. Defaults to 10.
#' @param prob_multiplet Probability threshold by which confident transparent multiplets are flagged.
#' @param dip_test_p_cutoff P-value cutoff for Hartigan's dip test of multimodality. If significant, a k=2 GMM model will be fit. Defaults to 0.2.
#' @param ... Additional arguments passed to `mclust::Mclust()`
#' @returns A list with cell genotype counts, barcodes of putative heterozygous cells, input dataframe, and optional GMM model fit object
#' @examples
#' data(cocktail)
#' mydata <- clean_crispresso_output(cocktail)
#' myhoms <- find_homs(mydata)
#' myput_hets <- find_putative_hets(cleaned_crispresso_allele_df, myhoms)
#'
find_putative_hets <- function(cleaned_crispresso_allele_df,
                               hom_object = NULL,
                               output_hom = FALSE,
                               output_model_fit = FALSE,
                               seed = 3594,
                               min_cell_number = 10,
                               prob_multiplet = NULL,
                               dip_test_p_cutoff = 0.2,
                               ...) {

  if (is.null(hom_object)) {
    set.seed(seed)
    hom_object <- GUMM::find_homs(cleaned_crispresso_allele_df)
  }

  allele_ratio_df <- cleaned_crispresso_allele_df %>%
    dplyr::filter(!sample %in% unlist(hom_object$homozygous_barcodes)) %>%
    dplyr::group_by(sample) %>%
    dplyr::arrange(desc(percent_reads)) %>%
    dplyr::slice(1:3) %>%
    dplyr::mutate(allele_ratio = log2(percent_reads[2] / percent_reads[3])) %>%
    dplyr::ungroup() %>%
    dplyr::select(sample, allele_ratio) %>%
    dplyr::distinct()

  het_whitelist <- dplyr::filter(allele_ratio_df, is.na(allele_ratio)) %>%
    dplyr::mutate(gmm_het = "putative_heterozygous", probability = 1)
  allele_ratio_df <- dplyr::filter(allele_ratio_df, !is.na(allele_ratio))

  if (nrow(allele_ratio_df) < min_cell_number) {

    het_df <- tibble::tibble(sample = unique(cleaned_crispresso_allele_df$sample), gmm_het = "putative_heterozygous") %>%
      dplyr::mutate(probability = 1) %>%
      dplyr::filter(!sample %in% unlist(hom_object$homozygous_barcodes))

    output_object <- list(count_table = table(het_df$gmm_het),
                          putative_heterozygous_barcodes = het_df$sample[het_df$gmm_het == "putative_heterozygous"],
                          data = het_df)

    warning("No transparent multiplets detected. All cells are diploid at selected loci", immediate. = TRUE)

  } else {

    # fit GMM
    set.seed(seed)
    myp <- diptest::dip.test(allele_ratio_df$allele_ratio)$p.value # implement dip test to determine if allele ratios are bimodal or unimodal (occurs when you have a pure population of cells)
    if (myp > dip_test_p_cutoff) {
      G <- 1
    } else {
      G <- 2
    }
    mclust_fit <- mclust::Mclust(allele_ratio_df$allele_ratio, G = G, ...)

    # assign cluster labels
    # mean will not be a named vector if allele ratio distribution is unimodal. het_clust_label will be NULL and no transparent multiiplets will be flagged.
    het_clust_label <- names(mclust_fit$parameters$mean)[which.max(mclust_fit$parameters$mean)]

    het_df <- tibble::tibble(allele_ratio_df,
                             gmm_het = dplyr::case_when(as.character(mclust_fit$classification) %in% het_clust_label ~ "putative_heterozygous",
                                                        is.null(het_clust_label) ~ "confident_heterozygous",
                                                        TRUE ~ "transparent_multiplet")) %>%
      dplyr::mutate(probability = apply(mclust_fit$z, 1, max)) %>%
      dplyr::bind_rows(het_whitelist)

    if (!is.null(prob_multiplet)) {
      het_df <- het_df %>%
        dplyr::mutate(gmm_het = ifelse(gmm_het %in% "transparent_multiplet" & probability < prob_multiplet, "putative_heterozygous", gmm_het))
    }

    output_object <- list(count_table = table(het_df$gmm_het),
                          putative_heterozygous_barcodes = het_df$sample[het_df$gmm_het %in% c("putative_heterozygous", "confident_heterozygous")],
                          data = het_df)

    if (output_model_fit) {
      output_object <- c(output_object, list(mix_model_fit = mclust_fit))
    }

  }

  if (output_hom) {
    output_object <- c(output_object, list(hom_object = hom_object))
  }

  return(output_object)

}

#' Separate confident heterozygous cells from opaque multiplets
#'
#' Identify opaque multiplets which have allele frequency distributions similar to true heterozygous cells (no noise alleles). These droplets tend to have indel profile combinations that are rare based on their correlation structure across entire population of cells. A multivariate Gaussian mixture model is fit to all allele counts to separate true heterozygous cells from opaque multiplets.
#'
#' @param cleaned_crispresso_allele_df Cleaned allele dataframe generated by `clean_crispresso_output()`
#' @param putative_het_object List object output by `find_putative_hets()`
#' @param dimred Logical indicating if PCA should be run on log-transformed allele read counts prior to fitting GMM. Defaults to TRUE.
#' @param npcs Integer value indicating how many principal components should be passed to GMM. Cannot be more than number of unique allele features.
#' @param output_model_fit Logical indicating if the heterozygous model fit should be included in function output. Default is FALSE.
#' @param skip_if_too_many_opaques Logical indicating if opaque detection should abort if too many are being called.
#' @param prob_multiplet Probability threshold indicating how confident opaque multiplet prediction is to be flagged.
#' @param dip_test_p_cutoff P-value cutoff for Hartigan's dip test of multimodality. If significant, a k=2 GMM model will be fit. Defaults to 0.2.
#' @param seed Seed for GMM initialization
#' @param ... Additional arguments passed to `mclust::Mclust()`
#' @returns A list with cell genotype counts, barcodes of putative heterozygous cells, input dataframe, and optional GMM model fit object
#' @examples
#' data(cocktail)
#' mydata <- clean_crispresso_output(cocktail)
#' myhoms <- find_homs(mydata)
#' myput_hets <- find_putative_hets(cleaned_crispresso_allele_df, myhoms)
#' myhets <- refine_hets(myput_hets, cleaned_crispresso_allele_df)
#'
refine_hets <- function(cleaned_crispresso_allele_df,
                        putative_het_object,
                        allele_features,
                        dimred = TRUE,
                        npcs = 2,
                        output_model_fit = FALSE,
                        prob_multiplet = NULL,
                        seed = 26433,
                        skip_if_too_many_opaques = FALSE,
                        dip_test_p_cutoff = 0.2,
                        ...) {

  af_matrix <- cleaned_crispresso_allele_df %>%
    dplyr::filter(sample %in% putative_het_object$putative_heterozygous_barcodes) %>%
    dplyr::select(sample, edited_allele_pattern, number_reads)

  af_matrix <- af_matrix %>%
    dplyr::mutate(edited_allele_pattern = ifelse(!edited_allele_pattern %in% allele_features, "sequencing_noise", edited_allele_pattern)) %>%
    dplyr::group_by(sample, edited_allele_pattern) %>%
    dplyr::summarize(number_reads = sum(number_reads)) %>%
    dplyr::ungroup()

  unique_indels <- unique(af_matrix$edited_allele_pattern)

  if (length(unique_indels) == 1) {

    stop("Make sure 'allele_features' are present in 'cleaned_crispresso_allele_df'.")

  } else if (length(unique_indels) < 3) {

    stop("Not enough unique indels (<3) to run opaque multiplet detection.")

  } else {

    af_matrix <- af_matrix %>%
      tidyr::pivot_wider(names_from = edited_allele_pattern, values_from = number_reads, values_fill = 0)

    feature_matrix <- af_matrix %>%
      dplyr::mutate_if(is.double, .funs = function(arg) log1p(arg)) %>%
      dplyr::select(sample, one_of(unique_indels)) %>%
      as.data.frame() %>%
      tibble::column_to_rownames("sample") %>%
      as.matrix()

    if (dimred) {

      feature_matrix <- feature_matrix %>%
        scale() %>%
        t() %>%
        prcomp()
      stopifnot(npcs <= length(unique_indels))
      feature_matrix <- feature_matrix$rotation[, 1:npcs]

    }

    # Fit GMM after testing for bimodality using Hartigan's Dip Test
    myp <- diptest::dip.test(feature_matrix[, "PC1"])$p.value # implement dip test to determine if allele ratios are bimodal or unimodal (occurs when you have a pure population of cells)
    if (myp > dip_test_p_cutoff) {
      G <- 1
    } else {
      G <- 2
    }
    set.seed(seed)
    mclust_fit <- mclust::Mclust(feature_matrix, G = G, ...)

    # Find heterozygous cluster by computing determinant of sigma
    if (length(unique(mclust_fit$classification)) > 1) {

      det1 <- det(mclust_fit$parameters$variance$sigma[,,1])
      det2 <- det(mclust_fit$parameters$variance$sigma[,,2])
      dense_cluster <- which.min(c(det1, det2))
      cluster_table <- table(mclust_fit$classification)

      if (which.max(cluster_table) != dense_cluster) {
        warning("Predicted true heterozygous cluster contains smaller number of cells than predicted opaque multiplet cluster suggesting putative heterzygous cell population is too heterogeneous.", immediate. = TRUE)
        if (skip_if_too_many_opaques)  het_clust_label <- unique(mclust_fit$classification) else het_clust_label <- as.character(dense_cluster)
      } else {
        het_clust_label <- as.character(dense_cluster)
      }

    } else {
     het_clust_label <- 1
    }

    feature_matrix <- feature_matrix %>%
      as.data.frame() %>%
      tibble::rownames_to_column("sample")

    het_df <- data.frame(feature_matrix,
                         gmm_confident_het = ifelse(as.character(mclust_fit$classification) %in% het_clust_label,
                                                    "confident_heterozygous",
                                                    "opaque_multiplet")) %>%
      dplyr::mutate(probability = apply(mclust_fit$z, 1, max))

    if (!is.null(prob_multiplet)) {
      het_df <- het_df %>%
        dplyr::mutate(gmm_confident_het = ifelse(gmm_confident_het %in% "opaque_multiplet" & probability < prob_multiplet, "confident_heterozygous", gmm_confident_het))
    }

    output_object <- list(count_table = table(het_df$gmm_confident_het),
                          confident_heterozygous_barcodes = het_df$sample[het_df$gmm_confident_het == "confident_heterozygous"],
                          data = het_df)

    if (output_model_fit) {
      output_object <- c(output_object, list(mix_model_fit = mclust_fit))
    }

    return(output_object)

  }

}
